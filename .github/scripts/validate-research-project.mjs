#!/usr/bin/env node

/**
 * Research Project PR Validator
 *
 * Validates that PRs to the research-hub contain legitimate research projects
 * generated by the research-visualizer skill. Checks structure, metadata,
 * telemetry, content quality, and anti-spam signals.
 *
 * Exit codes:
 *   0 = all checks passed
 *   1 = one or more checks failed
 *
 * Outputs a JSON report to stdout and a markdown summary to GITHUB_STEP_SUMMARY.
 */

import { readFileSync, existsSync, readdirSync, statSync, appendFileSync, writeFileSync } from 'fs';
import { join, basename, extname } from 'path';

// â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const VALID_LENSES = ['standard', 'product', 'population', 'behavior', 'industry', 'culture'];
const VALID_VISIBILITIES = ['local', 'personal', 'public'];

const REQUIRED_REGISTRY_FIELDS = [
  'slug', 'title', 'subtitle', 'query', 'lens', 'icon', 'accentColor', 'createdAt',
];

const REQUIRED_TELEMETRY_FIELDS = [
  'runStartedAt', 'runCompletedAt', 'durationMinutes', 'skillVersion',
  'userPrompt', 'researchPlan', 'searchesPerformed', 'sourcesCount',
  'sectionsBuilt', 'chartsBuilt', 'filesGenerated', 'dataPointsCollected',
  'phaseTiming',
];

const REQUIRED_PHASE_TIMING_FIELDS = [
  'environment', 'interpret', 'survey', 'discover', 'research', 'analyze', 'build', 'present',
];

const REQUIRED_CONTENT_ANALYSIS_FIELDS = [
  'fleschKincaidGrade', 'fleschKincaidLabel', 'bloomsLevel', 'bloomsLabel', 'totalWords',
];

const REQUIRED_HOURS_SAVED_FIELDS = [
  'researchHours', 'totalHoursSaved', 'equivalentLabel', 'productionHours',
];

const REQUIRED_CONSUMPTION_TIME_FIELDS = [
  'estimatedMinutes', 'estimatedLabel',
];

const MIN_QUERY_LENGTH = 15;
const MIN_DATA_FILE_SIZE = 200;       // bytes â€” a real data file has substance
const MIN_COMPONENT_COUNT = 2;        // at least Overview + Sources
const MIN_CHARTS_BUILT = 1;           // research dashboards have visualizations
const MIN_SECTIONS_BUILT = 3;         // at least a few sections
const MIN_SOURCES_COUNT = 3;          // real research cites sources
const MIN_SEARCHES_PERFORMED = 3;     // real research involves searching
const MIN_DATA_POINTS = 10;           // real research has data
const MIN_TOTAL_WORDS = 500;          // real research has substantial text
const MAX_DURATION_MINUTES = 1440;    // 24 hours â€” sanity check
const KEBAB_CASE_REGEX = /^[a-z0-9]+(-[a-z0-9]+)*$/;

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ValidationReport {
  constructor(projectSlug) {
    this.slug = projectSlug;
    this.checks = [];
    this.passed = 0;
    this.failed = 0;
    this.warnings = 0;
  }

  pass(category, message) {
    this.checks.push({ status: 'pass', category, message });
    this.passed++;
  }

  fail(category, message) {
    this.checks.push({ status: 'fail', category, message });
    this.failed++;
  }

  warn(category, message) {
    this.checks.push({ status: 'warn', category, message });
    this.warnings++;
  }

  get ok() {
    return this.failed === 0;
  }

  toMarkdown() {
    const icon = this.ok ? 'âœ…' : 'âŒ';
    const status = this.ok ? 'PASSED' : 'FAILED';
    let md = `## ${icon} Validation ${status}: \`${this.slug}\`\n\n`;
    md += `| Result | Category | Detail |\n|--------|----------|--------|\n`;
    for (const c of this.checks) {
      const emoji = c.status === 'pass' ? 'âœ…' : c.status === 'fail' ? 'âŒ' : 'âš ï¸';
      md += `| ${emoji} | ${c.category} | ${c.message} |\n`;
    }
    md += `\n**Summary:** ${this.passed} passed, ${this.failed} failed, ${this.warnings} warnings\n`;
    return md;
  }
}

function isValidISO8601(str) {
  if (typeof str !== 'string') return false;
  const d = new Date(str);
  return !isNaN(d.getTime()) && str.includes('T');
}

function fileContainsPattern(filePath, pattern) {
  try {
    const content = readFileSync(filePath, 'utf-8');
    return pattern.test(content);
  } catch {
    return false;
  }
}

function getFileSize(filePath) {
  try {
    return statSync(filePath).size;
  } catch {
    return 0;
  }
}

function countFilesRecursive(dir, ext) {
  let count = 0;
  if (!existsSync(dir)) return 0;
  for (const entry of readdirSync(dir, { withFileTypes: true })) {
    if (entry.isDirectory()) {
      count += countFilesRecursive(join(dir, entry.name), ext);
    } else if (!ext || extname(entry.name) === ext) {
      count++;
    }
  }
  return count;
}

// â”€â”€â”€ Detect Changed Projects â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function detectProjectsFromArgs() {
  // Accept project slugs as CLI args, or detect from changed files env var
  const args = process.argv.slice(2);
  if (args.length > 0) return args;

  // Fallback: scan for all projects in src/projects/
  const projectsDir = join(process.cwd(), 'src', 'projects');
  if (!existsSync(projectsDir)) return [];
  return readdirSync(projectsDir, { withFileTypes: true })
    .filter(d => d.isDirectory())
    .map(d => d.name);
}

// â”€â”€â”€ Parse Registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function parseRegistry(registryPath) {
  /**
   * Parse the projectRegistry array from index.js.
   * Since it's an ES module with lazy() calls we can't just import it,
   * so we extract the projectRegistry array via regex/eval.
   */
  const content = readFileSync(registryPath, 'utf-8');

  // Extract the projectRegistry array content between the brackets
  const match = content.match(/export\s+const\s+projectRegistry\s*=\s*\[([\s\S]*?)\];/);
  if (!match) return null;

  // Clean up: remove trailing commas before ] and convert single quotes to double
  let arrayContent = match[1];

  // Replace single-quoted strings with double-quoted (handle escaped quotes)
  // This is a simplified approach â€” works for the known registry format
  try {
    // Wrap in array brackets and evaluate as JS
    // We need to handle: single quotes, template literals, trailing commas
    const cleaned = `[${arrayContent}]`
      // Remove comments
      .replace(/\/\/.*$/gm, '')
      // null stays as null, true/false stay as-is
      ;

    // Use Function constructor to evaluate (safer than eval, no global scope)
    const fn = new Function(`return ${cleaned}`);
    return fn();
  } catch (e) {
    // If parsing fails, try a more aggressive approach
    try {
      // Extract individual objects using a simpler pattern
      const objects = [];
      const objRegex = /\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g;
      let objMatch;
      while ((objMatch = objRegex.exec(arrayContent)) !== null) {
        try {
          const fn = new Function(`return ${objMatch[0]}`);
          objects.push(fn());
        } catch {
          // Skip unparseable entries
        }
      }
      return objects.length > 0 ? objects : null;
    } catch {
      return null;
    }
  }
}

// â”€â”€â”€ Validation Checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function validateStructure(report, projectDir, slug) {
  const appPath = join(projectDir, 'App.jsx');
  const componentsDir = join(projectDir, 'components');
  const dataDir = join(projectDir, 'data');

  // App.jsx exists
  if (existsSync(appPath)) {
    report.pass('Structure', '`App.jsx` exists');
  } else {
    report.fail('Structure', '`App.jsx` is missing');
  }

  // components/ directory exists
  if (existsSync(componentsDir) && statSync(componentsDir).isDirectory()) {
    const componentFiles = readdirSync(componentsDir).filter(f => f.endsWith('.jsx'));
    if (componentFiles.length >= MIN_COMPONENT_COUNT) {
      report.pass('Structure', `\`components/\` has ${componentFiles.length} JSX files (min: ${MIN_COMPONENT_COUNT})`);
    } else {
      report.fail('Structure', `\`components/\` has only ${componentFiles.length} JSX files (min: ${MIN_COMPONENT_COUNT})`);
    }

    // Check for required components
    if (componentFiles.includes('Overview.jsx')) {
      report.pass('Structure', '`Overview.jsx` component present');
    } else {
      report.fail('Structure', '`Overview.jsx` component missing â€” every research project needs an overview');
    }

    if (componentFiles.includes('Sources.jsx')) {
      report.pass('Structure', '`Sources.jsx` component present');
    } else {
      report.fail('Structure', '`Sources.jsx` component missing â€” research must cite sources');
    }
  } else {
    report.fail('Structure', '`components/` directory is missing');
  }

  // data/ directory exists with files
  if (existsSync(dataDir) && statSync(dataDir).isDirectory()) {
    const dataFiles = readdirSync(dataDir).filter(f => f.endsWith('.js'));
    if (dataFiles.length > 0) {
      report.pass('Structure', `\`data/\` has ${dataFiles.length} data file(s)`);

      // Check data files have substance
      let hasSubstantialData = false;
      for (const df of dataFiles) {
        const size = getFileSize(join(dataDir, df));
        if (size >= MIN_DATA_FILE_SIZE) {
          hasSubstantialData = true;
        }
      }
      if (hasSubstantialData) {
        report.pass('Structure', 'Data files have substantial content');
      } else {
        report.fail('Structure', `All data files are under ${MIN_DATA_FILE_SIZE} bytes â€” likely empty or placeholder`);
      }
    } else {
      report.fail('Structure', '`data/` directory has no .js files');
    }
  } else {
    report.fail('Structure', '`data/` directory is missing');
  }
}

function validateRegistryEntry(report, entry, slug) {
  if (!entry) {
    report.fail('Registry', `No registry entry found for slug \`${slug}\` in \`projects/index.js\``);
    return;
  }

  report.pass('Registry', `Registry entry found for \`${slug}\``);

  // Required fields
  for (const field of REQUIRED_REGISTRY_FIELDS) {
    if (entry[field] !== undefined && entry[field] !== null && entry[field] !== '') {
      report.pass('Registry', `\`${field}\` is present`);
    } else {
      report.fail('Registry', `\`${field}\` is missing or empty`);
    }
  }

  // Slug format
  if (typeof entry.slug === 'string' && KEBAB_CASE_REGEX.test(entry.slug)) {
    report.pass('Registry', `Slug \`${entry.slug}\` is valid kebab-case`);
  } else {
    report.fail('Registry', `Slug \`${entry.slug}\` is not valid kebab-case`);
  }

  // Lens validation
  if (VALID_LENSES.includes(entry.lens)) {
    report.pass('Registry', `Lens \`${entry.lens}\` is a recognized research lens`);
  } else {
    report.fail('Registry', `Lens \`${entry.lens}\` is not recognized (valid: ${VALID_LENSES.join(', ')})`);
  }

  // CreatedAt is valid ISO 8601
  if (isValidISO8601(entry.createdAt)) {
    report.pass('Registry', `\`createdAt\` is valid ISO 8601: ${entry.createdAt}`);
  } else {
    report.fail('Registry', `\`createdAt\` is not valid ISO 8601`);
  }

  // Query minimum length
  if (typeof entry.query === 'string' && entry.query.length >= MIN_QUERY_LENGTH) {
    report.pass('Registry', `Query is ${entry.query.length} chars (min: ${MIN_QUERY_LENGTH})`);
  } else {
    report.fail('Registry', `Query is too short â€” real research needs a substantive prompt (min: ${MIN_QUERY_LENGTH} chars)`);
  }

  // Title and subtitle should be meaningful
  if (typeof entry.title === 'string' && entry.title.length >= 5) {
    report.pass('Registry', `Title \`${entry.title}\` looks reasonable`);
  } else {
    report.fail('Registry', 'Title is too short or missing');
  }

  // Visibility field (optional, but validated if present)
  if (entry.visibility !== undefined) {
    if (VALID_VISIBILITIES.includes(entry.visibility)) {
      report.pass('Registry', `Visibility \`${entry.visibility}\` is valid`);
    } else {
      report.fail('Registry', `Visibility \`${entry.visibility}\` is not recognized (valid: ${VALID_VISIBILITIES.join(', ')})`);
    }
  }
}

function validateTelemetry(report, telemetry) {
  if (!telemetry || typeof telemetry !== 'object') {
    report.fail('Telemetry', 'No telemetry object found â€” research projects must include build telemetry');
    return;
  }

  report.pass('Telemetry', 'Telemetry object present');

  // Required top-level fields
  for (const field of REQUIRED_TELEMETRY_FIELDS) {
    if (telemetry[field] !== undefined && telemetry[field] !== null) {
      report.pass('Telemetry', `\`${field}\` is present`);
    } else {
      report.fail('Telemetry', `\`${field}\` is missing`);
    }
  }

  // Timestamps
  if (isValidISO8601(telemetry.runStartedAt)) {
    report.pass('Telemetry', `\`runStartedAt\` is valid ISO 8601`);
  } else if (telemetry.runStartedAt !== undefined) {
    report.fail('Telemetry', `\`runStartedAt\` is not valid ISO 8601`);
  }

  if (isValidISO8601(telemetry.runCompletedAt)) {
    report.pass('Telemetry', `\`runCompletedAt\` is valid ISO 8601`);
  } else if (telemetry.runCompletedAt !== undefined) {
    report.fail('Telemetry', `\`runCompletedAt\` is not valid ISO 8601`);
  }

  // Duration sanity
  if (typeof telemetry.durationMinutes === 'number') {
    if (telemetry.durationMinutes > 0 && telemetry.durationMinutes <= MAX_DURATION_MINUTES) {
      report.pass('Telemetry', `Duration: ${telemetry.durationMinutes} minutes`);
    } else {
      report.fail('Telemetry', `Duration ${telemetry.durationMinutes} min is outside sane range (1-${MAX_DURATION_MINUTES})`);
    }
  }

  // Phase timing
  if (telemetry.phaseTiming && typeof telemetry.phaseTiming === 'object') {
    const missingPhases = REQUIRED_PHASE_TIMING_FIELDS.filter(p => telemetry.phaseTiming[p] === undefined);
    if (missingPhases.length === 0) {
      report.pass('Telemetry', 'All phase timing fields present');
    } else {
      report.fail('Telemetry', `Missing phase timing fields: ${missingPhases.join(', ')}`);
    }
  }

  // Numeric sanity checks
  if (typeof telemetry.searchesPerformed === 'number' && telemetry.searchesPerformed >= MIN_SEARCHES_PERFORMED) {
    report.pass('Telemetry', `${telemetry.searchesPerformed} searches performed (min: ${MIN_SEARCHES_PERFORMED})`);
  } else if (typeof telemetry.searchesPerformed === 'number') {
    report.fail('Telemetry', `Only ${telemetry.searchesPerformed} searches â€” real research requires more (min: ${MIN_SEARCHES_PERFORMED})`);
  }

  if (typeof telemetry.sourcesCount === 'number' && telemetry.sourcesCount >= MIN_SOURCES_COUNT) {
    report.pass('Telemetry', `${telemetry.sourcesCount} sources cited (min: ${MIN_SOURCES_COUNT})`);
  } else if (typeof telemetry.sourcesCount === 'number') {
    report.fail('Telemetry', `Only ${telemetry.sourcesCount} sources â€” research must cite real sources (min: ${MIN_SOURCES_COUNT})`);
  }

  if (typeof telemetry.sectionsBuilt === 'number' && telemetry.sectionsBuilt >= MIN_SECTIONS_BUILT) {
    report.pass('Telemetry', `${telemetry.sectionsBuilt} sections built (min: ${MIN_SECTIONS_BUILT})`);
  } else if (typeof telemetry.sectionsBuilt === 'number') {
    report.fail('Telemetry', `Only ${telemetry.sectionsBuilt} sections â€” dashboards need substance (min: ${MIN_SECTIONS_BUILT})`);
  }

  if (typeof telemetry.chartsBuilt === 'number' && telemetry.chartsBuilt >= MIN_CHARTS_BUILT) {
    report.pass('Telemetry', `${telemetry.chartsBuilt} charts built (min: ${MIN_CHARTS_BUILT})`);
  } else if (typeof telemetry.chartsBuilt === 'number') {
    report.fail('Telemetry', `Only ${telemetry.chartsBuilt} charts â€” research dashboards must have visualizations`);
  }

  if (typeof telemetry.dataPointsCollected === 'number' && telemetry.dataPointsCollected >= MIN_DATA_POINTS) {
    report.pass('Telemetry', `${telemetry.dataPointsCollected} data points collected (min: ${MIN_DATA_POINTS})`);
  } else if (typeof telemetry.dataPointsCollected === 'number') {
    report.fail('Telemetry', `Only ${telemetry.dataPointsCollected} data points â€” research needs real data (min: ${MIN_DATA_POINTS})`);
  }

  // Content analysis
  if (telemetry.contentAnalysis && typeof telemetry.contentAnalysis === 'object') {
    const ca = telemetry.contentAnalysis;
    const missingCA = REQUIRED_CONTENT_ANALYSIS_FIELDS.filter(f => ca[f] === undefined);
    if (missingCA.length === 0) {
      report.pass('Telemetry', `Content analysis present â€” ${ca.fleschKincaidLabel}, ${ca.bloomsLabel}, ${ca.totalWords} words`);
    } else {
      report.fail('Telemetry', `Content analysis missing fields: ${missingCA.join(', ')}`);
    }

    if (typeof ca.totalWords === 'number' && ca.totalWords >= MIN_TOTAL_WORDS) {
      report.pass('Telemetry', `Word count: ${ca.totalWords} (min: ${MIN_TOTAL_WORDS})`);
    } else if (typeof ca.totalWords === 'number') {
      report.fail('Telemetry', `Word count ${ca.totalWords} is too low â€” research dashboards have substantial text (min: ${MIN_TOTAL_WORDS})`);
    }

    if (typeof ca.fleschKincaidGrade === 'number' && ca.fleschKincaidGrade >= 1 && ca.fleschKincaidGrade <= 20) {
      report.pass('Telemetry', `Flesch-Kincaid grade: ${ca.fleschKincaidGrade} (sane range)`);
    } else if (typeof ca.fleschKincaidGrade === 'number') {
      report.warn('Telemetry', `Flesch-Kincaid grade ${ca.fleschKincaidGrade} is unusual`);
    }

    if (typeof ca.bloomsLevel === 'number' && ca.bloomsLevel >= 1 && ca.bloomsLevel <= 6) {
      report.pass('Telemetry', `Bloom's level: ${ca.bloomsLevel} (${ca.bloomsLabel})`);
    } else if (typeof ca.bloomsLevel === 'number') {
      report.fail('Telemetry', `Bloom's level ${ca.bloomsLevel} is out of range (1-6)`);
    }
  } else {
    report.fail('Telemetry', 'Content analysis section is missing');
  }

  // Hours saved
  if (telemetry.hoursSaved && typeof telemetry.hoursSaved === 'object') {
    const hs = telemetry.hoursSaved;
    const missingHS = REQUIRED_HOURS_SAVED_FIELDS.filter(f => hs[f] === undefined);
    if (missingHS.length === 0) {
      report.pass('Telemetry', `Hours saved present â€” ${hs.totalHoursSaved}h total (${hs.equivalentLabel})`);
    } else {
      report.fail('Telemetry', `Hours saved missing fields: ${missingHS.join(', ')}`);
    }
  } else {
    report.fail('Telemetry', 'Hours saved section is missing');
  }

  // Consumption time
  if (telemetry.consumptionTime && typeof telemetry.consumptionTime === 'object') {
    const ct = telemetry.consumptionTime;
    const missingCT = REQUIRED_CONSUMPTION_TIME_FIELDS.filter(f => ct[f] === undefined);
    if (missingCT.length === 0) {
      report.pass('Telemetry', `Consumption time present â€” ${ct.estimatedLabel}`);
    } else {
      report.fail('Telemetry', `Consumption time missing fields: ${missingCT.join(', ')}`);
    }
  } else {
    report.fail('Telemetry', 'Consumption time section is missing');
  }

  // Skill version
  if (typeof telemetry.skillVersion === 'string' && /^\d+\.\d+/.test(telemetry.skillVersion)) {
    report.pass('Telemetry', `Skill version: ${telemetry.skillVersion}`);
  } else if (telemetry.skillVersion !== undefined) {
    report.warn('Telemetry', `Skill version \`${telemetry.skillVersion}\` doesn't look like a version number`);
  }

  // User prompt should be substantive
  if (typeof telemetry.userPrompt === 'string' && telemetry.userPrompt.length >= MIN_QUERY_LENGTH) {
    report.pass('Telemetry', `User prompt is ${telemetry.userPrompt.length} chars`);
  } else if (telemetry.userPrompt !== undefined) {
    report.fail('Telemetry', 'User prompt is too short â€” real research starts with a real question');
  }

  // Research plan should be substantive
  if (typeof telemetry.researchPlan === 'string' && telemetry.researchPlan.length >= 50) {
    report.pass('Telemetry', `Research plan is ${telemetry.researchPlan.length} chars`);
  } else if (telemetry.researchPlan !== undefined) {
    report.fail('Telemetry', 'Research plan is too short â€” should contain the full checkpoint summary');
  }
}

function validateContentQuality(report, projectDir) {
  const appPath = join(projectDir, 'App.jsx');
  const componentsDir = join(projectDir, 'components');
  const dataDir = join(projectDir, 'data');

  // App.jsx should import React and use JSX patterns
  if (existsSync(appPath)) {
    const appContent = readFileSync(appPath, 'utf-8');

    if (/import\s+.*react/i.test(appContent) || /from\s+['"]react['"]/i.test(appContent)) {
      report.pass('Content', '`App.jsx` imports React');
    } else {
      report.fail('Content', '`App.jsx` does not import React â€” not a valid React component');
    }

    if (/return\s*\(/.test(appContent) && /</.test(appContent)) {
      report.pass('Content', '`App.jsx` contains JSX return statement');
    } else {
      report.fail('Content', '`App.jsx` does not appear to return JSX');
    }

    // Check for section/navigation patterns (research dashboards have internal nav)
    if (/section|activeSection|setActive|sidebar|nav/i.test(appContent)) {
      report.pass('Content', '`App.jsx` has section navigation patterns (research dashboard structure)');
    } else {
      report.warn('Content', '`App.jsx` may lack section navigation â€” research dashboards typically have internal nav');
    }
  }

  // Components should use recharts or similar visualization library
  if (existsSync(componentsDir)) {
    const componentFiles = readdirSync(componentsDir).filter(f => f.endsWith('.jsx'));
    let hasChartImport = false;
    let hasInsightCallout = false;

    for (const cf of componentFiles) {
      const content = readFileSync(join(componentsDir, cf), 'utf-8');
      if (/recharts|chart|Chart|BarChart|LineChart|PieChart|RadarChart|AreaChart|ScatterChart/i.test(content)) {
        hasChartImport = true;
      }
      if (/InsightCallout|insight|callout/i.test(content)) {
        hasInsightCallout = true;
      }
    }

    if (hasChartImport) {
      report.pass('Content', 'Components use chart/visualization libraries (recharts)');
    } else {
      report.fail('Content', 'No chart/visualization imports found â€” research dashboards must have data visualizations');
    }

    if (hasInsightCallout) {
      report.pass('Content', 'Components include insight callouts (research analysis patterns)');
    } else {
      report.warn('Content', 'No InsightCallout patterns found â€” research dashboards typically highlight key findings');
    }
  }

  // Data files should export real data (arrays/objects with content)
  if (existsSync(dataDir)) {
    const dataFiles = readdirSync(dataDir).filter(f => f.endsWith('.js'));
    let hasExports = false;
    let totalDataSize = 0;

    for (const df of dataFiles) {
      const filePath = join(dataDir, df);
      const content = readFileSync(filePath, 'utf-8');
      totalDataSize += content.length;

      if (/export\s+(const|default|function)/.test(content)) {
        hasExports = true;
      }
    }

    if (hasExports) {
      report.pass('Content', 'Data files use ES module exports');
    } else {
      report.fail('Content', 'Data files do not export anything â€” must use ES module exports');
    }

    if (totalDataSize >= 1000) {
      report.pass('Content', `Total data content: ${(totalDataSize / 1024).toFixed(1)}KB`);
    } else {
      report.fail('Content', `Total data content is only ${totalDataSize} bytes â€” research data should be substantial`);
    }
  }
}

function validateProductLensExtras(report, entry, telemetry) {
  if (entry?.lens !== 'product') return;

  report.pass('Product Lens', 'Product comparison project detected â€” running additional checks');

  // Products compared should be present
  if (typeof telemetry?.productsCompared === 'number' && telemetry.productsCompared >= 3) {
    report.pass('Product Lens', `${telemetry.productsCompared} products compared (min: 3)`);
  } else if (telemetry?.productsCompared !== undefined && telemetry.productsCompared !== null) {
    report.fail('Product Lens', `Only ${telemetry.productsCompared} products compared â€” product comparisons need at least 3`);
  } else {
    report.fail('Product Lens', '`productsCompared` is missing for a product lens project');
  }
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  const projectSlugs = detectProjectsFromArgs();

  if (projectSlugs.length === 0) {
    console.log('No projects to validate.');
    process.exit(0);
  }

  const registryPath = join(process.cwd(), 'src', 'projects', 'index.js');
  let registry = null;
  if (existsSync(registryPath)) {
    registry = parseRegistry(registryPath);
  }

  const reports = [];
  let allPassed = true;

  for (const slug of projectSlugs) {
    const report = new ValidationReport(slug);
    const projectDir = join(process.cwd(), 'src', 'projects', slug);

    if (!existsSync(projectDir)) {
      report.fail('Structure', `Project directory \`src/projects/${slug}/\` does not exist`);
      reports.push(report);
      allPassed = false;
      continue;
    }

    // Find registry entry
    const entry = registry?.find(e => e.slug === slug) || null;

    // Run all validation checks
    validateStructure(report, projectDir, slug);
    validateRegistryEntry(report, entry, slug);
    validateTelemetry(report, entry?.telemetry);
    validateContentQuality(report, projectDir);
    validateProductLensExtras(report, entry, entry?.telemetry);

    reports.push(report);
    if (!report.ok) allPassed = false;
  }

  // Output markdown summary
  let summary = '# ðŸ”¬ Research Project Validation Report\n\n';
  for (const r of reports) {
    summary += r.toMarkdown() + '\n---\n\n';
  }

  const totalPassed = reports.reduce((s, r) => s + r.passed, 0);
  const totalFailed = reports.reduce((s, r) => s + r.failed, 0);
  const totalWarnings = reports.reduce((s, r) => s + r.warnings, 0);

  summary += `### Overall: ${totalPassed} passed, ${totalFailed} failed, ${totalWarnings} warnings across ${reports.length} project(s)\n`;

  // Write to GITHUB_STEP_SUMMARY if available
  if (process.env.GITHUB_STEP_SUMMARY) {
    appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
  }

  // Output JSON for programmatic consumption
  const jsonReport = {
    allPassed,
    projects: reports.map(r => ({
      slug: r.slug,
      passed: r.passed,
      failed: r.failed,
      warnings: r.warnings,
      ok: r.ok,
      checks: r.checks,
    })),
  };

  // Write markdown to a file for the PR comment action
  writeFileSync('validation-report.md', summary);

  console.log(JSON.stringify(jsonReport, null, 2));

  process.exit(allPassed ? 0 : 1);
}

main();
